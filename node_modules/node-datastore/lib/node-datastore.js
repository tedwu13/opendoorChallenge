/**
 * Data Library that provides consistent interface to various data models.
 * API provides powerful features to access and manipulate data
 * @author Sam Tsvilik
 * @version 1.0
 * @requires jQuery, node-jpath 2.0
 * @name DataStore
 * @namespace Data module functionality
 */
(function($, jpath, NULL, undef) {
	"use strict";
	/**
	 * @lends DataStore
	 */
	var STRING = 'string',
		NUMBER = 'number',
		OBJECT = "object",
		TRUE = !0,
		FALSE = !1,
		APS = Array.prototype.slice,
		APC = Array.prototype.concat,
		APP = Array.prototype.push,
		util = require("util"),
		events = require("events"),
		obj = {
			/*
			 * White-list returns only approved members of the object
			 * @o - Object that contains members
			 * @arrList - String array of white-listed members (only members you want in your output)
			 * @returs - Object
			 */
			whiteList: function(o, arrList) {
				var out = {};
				if (typeof(o) === OBJECT && $.isArray(arrList)) {
					for (var i = 0, l = arrList.length, name; l > i; i++) {
						name = arrList[i];
						if (name in o) {
							out[name] = o[name];
						}
					}
				}
				return out;
			},
			/*
			 * Black-list returns allmembers except those listed in the list
			 * @o - Object that contains members
			 * @arrList - String array of black-listed members (members you don't want in your output)
			 * @returs - Object
			 */
			blackList: function(o, arrList) {
				var out = {};
				if (typeof(o) === OBJECT && $.isArray(arrList)) {
					$.extend(out, o);
					for (var i = 0, l = arrList.length, name; l > i; i++) {
						name = arrList[i];
						if (name in out) {
							delete out[name];
						}
					}
				}
				return out;
			}
		};

	/**
	 * Ensures that object is an Array, if not it converts it to one
	 * @param  {Object} o Object to be evaluated as an Array
	 * @returns {Array} Object argument as an Array
	 * @private
	 */

	function toArray(o) {
		return o instanceof Array ? o : (o === NULL || o === undef) ? [] : [o];
	}

	/**
	 * Creates an Index map to all the rows
	 * @private
	 */

	function indexRows() {
		this.__index__.length = 0;
		//Index rows
		for (var i = 0, l = this.__data__.length; l > i; i++) {
			this.__data__[i].__rowIndex__ = i;
			this.__index__[i] = this.__data__[i];
		}
		return this;
	}

	/**
	 * Function to sort on multiple columns (runs in a scope of the DataStore instance)
	 * @private
	 */

	function sortMultiple( /*colObj1, colObj2*/ ) {
		var columns = APS.apply(arguments),
			opt, out, _a, _b;

		if (this.__data__.length && columns && columns.length) {
			this.__data__.sort(function(a, b) {
				//Looping through multiple columns to sort
				for (var c = 0; opt = columns[c]; c++) {
					_a = typeof(opt) === STRING ? a[opt] : opt.column ? a[opt.column] : NULL;
					_b = typeof(opt) === STRING ? b[opt] : opt.column ? b[opt.column] : NULL;
					if (_a !== NULL && _b !== NULL) {
						if (opt.type && opt.type === 'text') {
							_a = _a && _a + '';
							_b = _b && _b + '';
						} else if (opt.type && opt.type === NUMBER) {
							_a = _a && +_a;
							_b = _b && +_b;
						} else if (opt.type && opt.type === 'date') {
							_a = _a && typeof(_a) === 'date' && !isNaN(_a) && _a.valueOf();
							_b = _b && typeof(_b) === 'date' && !isNaN(_b) && _b.valueOf();
						}
						/* Compare values
						 * In multi-column sort, instead of returning value right-away,
						 * we break the for-loop to set initial sorting order and continue
						 */
						if ((opt.order || 'asc') === 'desc') {
							if (_a < _b) {
								out = 1;
								break;
							} else if (_b < _a) {
								out = -1;
								break;
							} else {
								out = 0;
							}
						} else {
							if (_a < _b) {
								out = -1;
								break;
							} else if (_b < _a) {
								out = 1;
								break;
							} else {
								out = 0;
							}
						}
					}
				}
				return out;
			});
		}
	}

	/**
	 * Returns an object that is a result of white/black list filtering
	 * @param  {Object} o  Object that needs to be filtered
	 * @param  {Array} wl Array of field names that are allowed to stay
	 * @param  {Array} bl Array of field names that should be filtered out
	 * @return {Object}    Result of the filtering
	 */

	function getSubset(o, wl, bl) {
		var out = wl && wl.length ? obj.whiteList(o, wl) : o;
		out = bl && wl.length ? obj.blackList(out, bl) : out;
		return out;
	}

	/**
	 * Base DataStore provides basic functionality to get, filter, sort data
	 * @name DataStore
	 * @class DataStore Encapsulates a data model unit and provides an API to access and manipulate data
	 * @property {Object} status Contains properties that change throughout the lifecycle of the DataStore
	 * @property {Object} config Contains DataStore configuration settings
	 * @param  {Array} data (optional) Array of row objects or arrays
	 * @param  {Object} opt Initialization options
	 * @param  {int} opt.pageSize Page size used for pagination
	 */

	function DataStore(data, opt) {

		//Two dimensional Array that represents r
		//ows of data
		this.__data__ = [];
		this.__index__ = [];
		this.config = {
			pageSize: 10
		};
		this.status = {
			page: 1,
			pageCount: 0,
			sortedColumn: NULL,
			sortOrder: 'asc',
			currentRange: {
				start: 0,
				end: 0
			}
		};
		//Extend built-in ocnfiguration
		if (typeof(opt) === OBJECT) {
			$.extend(this.config, opt);
		}
		//Handle dataNode subset
		if (this.config.dataNode !== undef && data !== undef) {
			this.__data__ = jpath.filter(data, this.config.dataNode);
		} else {
			this.__data__ = toArray(data);
		}
		//Calculate page count
		if (this.__data__ && this.__data__.length) {
			this.status.pageCount = Math.ceil(this.__data__.length / this.config.pageSize);
			this.status.currentRange.end = this.__data__.length;
		}
		//Index rows
		indexRows.apply(this);
		events.EventEmitter.call(this);
	}
	util.inherits(DataStore, events.EventEmitter);
	$.extend(DataStore.prototype, {
		/**
		 * Set configuration after init
		 * @returns {this}
		 */
		setConfig: function(opt) {
			if (typeof(opt) === OBJECT) {
				$.extend(this.config, opt);
			}
			return this;
		},
		/**
		 * Returns all or subset of rows
		 * Optional arguments:
		 * @param {Number} start Starting index
		 * @param {Number} end Ending index
		 * @returns {Array} Array of rows that fit between start and end range
		 */
		getRows: function( /*[start, [end]] (all)*/ ) {
			var args = APS.apply(arguments);
			return args.length ? APS.apply(this.__data__, args) : this.__data__;
		},
		/**
		 * Returns a row of data by it's __rowIndex__
		 * Note: Row index does not change after sort!
		 * @param {Number} index Row index value
		 * @returns {Object | Array} Row that matches index position
		 */
		getByRowIndex: function(index) {
			index = (index < 0) ? 0 : Math.min(index, this.__data__.length - 1);
			return this.__index__[index];
		},
		/**
		 * Alias to getByRowIndex
		 * @returns {Object | Array} Row that matches index position
		 */
		getRowByIndex: function() {
			return this.getByRowIndex.apply(this, arguments);
		},
		/**
		 * Sorts data
		 * @param {Object} opt Sorting options
		 * @example
		 *		column: index <number> | name <string> - column to sort data by
		 *		order: 'asc' | 'desc' - sort order
		 *		type: 'text' | 'number' | 'date' - datatype to sort by
		 *	@returns {this}
		 */
		sort: function( /*opt*/ ) {
			var args = APS.apply(arguments),
				max = args.length,
				opt = max ? typeof(args[0]) === OBJECT ? args[0] : typeof(args[0]) === STRING ? {
					column: args[0]
				} : NULL : NULL;
			if (max > 1) {
				this.emit("beforeSort", args);
				sortMultiple.apply(this, arguments);
				this.emit("sort", args);
			} else {
				if (opt) {
					this.emit("beforeSort", opt);
					this.status.sortedColumn = opt.column || NULL;
					this.status.sortOrder = opt.order || NULL;
					if (this.__data__.length) {
						var _a, _b;
						this.__data__.sort(function(a, b) {
							_a = typeof(opt) === STRING ? a[opt] : opt.column ? a[opt.column] : NULL;
							_b = typeof(opt) === STRING ? b[opt] : opt.column ? b[opt.column] : NULL;
							if (_a !== NULL && _b !== NULL) {
								if (opt.type && opt.type === 'text') {
									_a = _a && _a + '';
									_b = _b && _b + '';
								} else if (opt.type && opt.type === NUMBER) {
									_a = _a && +_a;
									_b = _b && +_b;
								} else if (opt.type && opt.type === 'date') {
									_a = _a && typeof(_a) === 'date' && !isNaN(_a) && _a.valueOf();
									_b = _b && typeof(_b) === 'date' && !isNaN(_b) && _b.valueOf();
								}
								//Compare values
								return ((opt.order || 'asc') === 'desc' ? -1 : 1) * (
								_a > _b ? 1 : _b > _a ? -1 : 0);
							}
							return 0;
						});
						this.emit("sort", opt);
					}
				}
			}
			return this;
		},
		/**
		 * Returns a paged range
		 * @param {Number} page Starting page (default: 1)
		 * @param {Number} pageSize Number of rows per page
		 * @returns {Array} An array or rows that fall in to a page range
		 */
		getPage: function(page, pageSize) {
			pageSize = typeof(pageSize) === NUMBER && !isNaN(pageSize) ? pageSize : this.config.pageSize;

			var max = this.__data__.length,
				pageCount = Math.ceil(max / pageSize) || 1,
				start, end;

			page = (typeof(page) === NUMBER && !isNaN(page)) ? (page > 0 && page <= pageCount) ? page : 1 : 1;

			this.status.page = page;
			this.status.pageCount = pageCount;

			if (max && pageCount) {
				start = (page - 1) * pageSize;
				end = start + pageSize;
				this.status.currentRange = {
					start: (start + 1),
					end: Math.min(end, max)
				};
				return this.getRows(start, end);
			}

			return NULL;
		},
		/**
		 * Note: Remote datasets should return value specified by the service and not local buffer length
		 * @returns {Number} Returns total rows count
		 */
		count: function() {
			return this.__data__.length;
		},
		/**
		 * Filter Data
		 * @param {String} expr String expression (jpath format)
		 * @example "*[field=value]" or "field_name"
		 * @returns {Array} - of matched values or NULL
		 */
		filter: function(expr, fn) {
			return jpath.filter(this.__data__, expr, fn);
		},
		/**
		 * Selects data based on jPath expression and returns it as a new DataStore object
		 * @return {DataStore}	jPath result wrapped in DataStore
		 */
		select: function() {
			return new DataStore(this.filter.apply(this, arguments));
		},
		/**
		 * Inserts a row
		 * @param {Object | Array} row An object or an array of values to represent a row
		 * @returns {this}
		 */
		insertRow: function(row) {
			if ($.isArray(row) || typeof(row) === OBJECT) {
				//Append a new row
				APP.apply(this.__data__, [row]);
				//Set the reference in the index
				APP.apply(this.__index__, [this.__data__[this.__data__.length - 1]]);
				//Set __rowIndex__
				row.__rowIndex__ = this.__data__.length - 1;
				//emit onInsert event
				this.emit("insert", row);
				//emit onChange event
				this.emit("change", this);
			}
			return this;
		},

		/**
		 * Sums all values in a column
		 * @param {String | int} column Column name or index
		 * @returns {Number} Sum of of all values in the column
		 */
		sum: function(column) {
			var max = this.__data__.length,
				buff = 0,
				row, value;
			while (max--) {
				row = this.__data__[max];
				if (column in row) {
					value = +row[column];
					if (!isNaN(value)) {
						buff += value;
					}
				}
			}
			return buff;
		},
		/**
		 * Average of all values in a column
		 * @param {String | int} column Column name or index
		 * @returns {Number} Average column value
		 */
		avg: function(column) {
			var max = this.__data__.length,
				count = 0,
				buff = 0,
				row, value;
			while (max--) {
				row = this.__data__[max];
				if (column in row) {
					value = +row[column];
					if (!isNaN(value)) {
						count++;
						buff += value;
					}
				}
			}
			return buff / count;
		},
		/**
		 * Max value in the column
		 * @param {String | int} column Column name or index
		 * @returns {Number} Maximum column value
		 */
		max: function(column) {
			var max = this.__data__.length,
				buff = [],
				row, value;
			while (max--) {
				row = this.__data__[max];
				if (column in row) {
					value = +row[column];
					if (!isNaN(value)) {
						APP.apply(buff, [value]);
					}
				}
			}
			return Math.max.apply(NULL, buff);
		},
		/**
		 * Min value in the column
		 * @param {String | int} column Column name or index
		 * @returns {Number} Minimal column value
		 */
		min: function(column) {
			var max = this.__data__.length,
				buff = [],
				row, value;
			while (max--) {
				row = this.__data__[max];
				if (column in row) {
					value = +row[column];
					if (!isNaN(value)) {
						APP.apply(buff, [value]);
					}
				}
			}
			return Math.min.apply(NULL, buff);
		},
		/**
		 * Unique values from a single column
		 * @param {String | int} column Column name or index
		 * @returns {Array} returns an array or unique column values
		 */
		unique: function(column) {
			var allColumnValues = this.filter(column),
				max = allColumnValues.length ? allColumnValues.length : 0,
				hash = {},
				buff = [],
				value;

			allColumnValues.sort();
			for (var i = 0; max > i; i++) {
				value = allColumnValues[i];
				if (value in hash) continue;
				else {
					APP.apply(buff, [value]);
					hash[value] = !0;
				}
			}
			return buff;
		},
		/**
		 * Concatinates rows from another DataStore or just two-dimmensional array
		 * @param  {DataStore | Array[Object]}  itemN items to be appended to this DataStore
		 * @returns {this}
		 */
		concat: function( /* item, [item1, item2, n] */ ) {
			var args = APS.apply(arguments),
				src;

			for (var i = 0; src = args[i]; i++) {
				if (src) {
					if (src instanceof DataStore) {
						this.__data__ = APC.apply(this.__data__, [src.__data__]);
					} else if ($.isArray(src)) {
						this.__data__ = APC.apply(this.__data__, [src]);
					}
				}
			}
			//Index rows
			indexRows.apply(this);
			//emit onChange event
			this.emit("change", this);
			return this;
		},
		/**
		 * Adjust the field data if one needs to be converted, cleaned-up or replaced.
		 * WARNING: This is an expensive function, use only for pre-processing, should not be performed in performance-sensitive context.
		 * This method has 2 signatures:
		 * 1. field, cb - where field is the name or index of the column in the row
		 * 2. cb - only callback is specified and it runs in the scope of the row, so any adjustments you can perform against row data directly
		 *
		 * Callaback has 2 signatures as well:
		 * 1. value, row - this signature applies to 1st call signature and passes into callback current value of the field specified and a ref. to row
		 * 2. row - this signature applies to 2nd call signature and passes into callback only row.
		 *
		 * @param {String} field (optional) Name of the field that will be accessed the main focus of adjustment
		 * @param {Function} cb Callback function that will fire for every row in the set
		 */
		adjustData: function() {
			var args = APS.apply(arguments),
				cb = args.slice(-1)[0],
				field = args[1] ? args[0] : undef;

			if ($.isFunction(cb)) for (var i = 0, r, v, c; r = this.__data__[i]; i++) {
				v = (field != undef) ? r[field] : undef;
				if (v !== undef) {
					c = cb.apply(r, [v, r]);
					r[field] = c ? c : v;
				} else {
					cb.apply(r, [r]);
				}
			}
			//emit onChange event
			this.emit("change", this);
			return this;
		},
		/**
		 * Joins existing DataStore (destination) with another Data (source) by column key, replacing/augmenting current row with values of the source row
		 * WARNING: This is an expensive function
		 * @param  {DataStore | Array[][]} sourceData - data to merge with
		 * @param  {String|Object} onColumn - merge on what unique column. You may use JSON notation to map source key to destination key { "destKey":"sourceKey" }
		 * @param  {Object} options various merge options.
		 * @param  {String} options.type Types of Join: inner(both keys match), differential(only non-matching), left(destination biased), right(source biased). Default: inner.
		 * @param  {Array} options.whiteList List of source field names that are allowed to be merged w/ destination row
		 * @param  {Array} options.blackList List of source field names that will be excluded when merging w/ destination row
		 * @returns {DataStore} new DataStore containing product of join
		 */
		join: function(sourceData, pkFk, options) {
			sourceData = (sourceData instanceof Array) ? new data.DataStore(sourceData) : sourceData;

			var tmp = [],
				pKey, fKey, dUniq, sUniq, dGroup, sGroup, dMatch, sMatch, i = 0,
				m, key, defaults = {
					type: "inner",
					blackList: null,
					whiteList: null
				},
				userOptions = $.extend(true, {}, defaults, options),
				subset;

			//Record original order
			this.adjustData(function(row) {
				row.__origOrder__ = i++;
			});
			//Get primary and foreign keys
			switch (typeof(pkFk)) {
			case STRING:
				pKey = fKey = pkFk;
				break;
			case OBJECT:
				$.each(pkFk, function(pk, fk) {
					pKey = pk;
					fKey = fk;
					return false;
				});
				break;
			}
			if (pKey && fKey) {
				//Unique values that retain order
				dUniq = this.unique(pKey);
				sUniq = sourceData.unique(fKey);
				//Hash maps grouped by key
				dGroup = this.groupBy(pKey);
				sGroup = sourceData.groupBy(fKey);

				switch (userOptions.type) {
				case "inner":
					for (i = 0, m = dUniq.length, key; m > i; i++) {
						key = dUniq[i];
						dMatch = dGroup[key][0];
						//If key is in sourceDate, insert a join between the two rows
						if (key in sGroup) {
							sMatch = sGroup[key][0];
							subset = getSubset(sMatch, userOptions.whiteList, userOptions.blackList);
							tmp.push($.extend(true, {}, dMatch, subset));
						}
					}
					break;
				case "differential":
					for (i = 0, m = sUniq.length, key; m > i; i++) {
						key = sUniq[i];
						sMatch = sGroup[key][0];
						subset = getSubset(sMatch, userOptions.whiteList, userOptions.blackList);
						//If key is in sourceDate, insert a join between the two rows
						if (!(key in dGroup)) {
							tmp.push($.extend(true, {}, subset));
						}
					}
					break;
				case "left":
					for (i = 0, m = dUniq.length, key; m > i; i++) {
						key = dUniq[i];
						dMatch = dGroup[key][0];
						//If key is in sourceDate, insert a join between the two rows
						if (key in sGroup) {
							sMatch = sGroup[key][0];
							subset = getSubset(sMatch, userOptions.whiteList, userOptions.blackList);
							tmp.push($.extend(true, {}, dMatch, subset));
						} else {
							tmp.push(dMatch);
						}
					}
					break;
				case "right":
					for (i = 0, m = sUniq.length, key; m > i; i++) {
						key = sUniq[i];
						sMatch = sGroup[key][0];
						subset = getSubset(sMatch, userOptions.whiteList, userOptions.blackList);
						//If key is in sourceDate, insert a join between the two rows
						if (key in dGroup) {
							dMatch = dGroup[key][0];
							tmp.push($.extend(true, {}, subset, dMatch));
						} else {
							tmp.push(sMatch);
						}
					}
					break;
				}
			}
			return new DataStore(tmp).sort("__origOrder__");
		},
		/**
		 * Returns only distinct rows by specified key field
		 * @param  {String} onField Field name
		 * @return {DataStore}  DataStore containing only distinct values
		 */
		distinct: function(onField) {
			var grouped = this.groupBy(onField),
				tmp = new DataStore();
			for (var key in grouped) {
				if (grouped.hasOwnProperty(key)) {
					tmp.insertRow(grouped[key][0]);
				}
			}
			return tmp;
		},
		/**
		 * Groups data by unique column values and creates and object tree
		 * You may specify multiple columns to group by and that will create a nested tree with rows being set as leafs
		 * @function
		 * @param {String} column One or more column name argument that data will be grouped by. Column name can be deep (i.e. have dots to traverse), but this operation will be slower.
		 * @returns {Object}
		 */
		groupBy: (function() {
			var rxReplaceQuote = /(\w+)(')([\w\s]?)/g;
			/**
			 * Gathers rows that match column value
			 * @private
			 */

			function getRowsByColumnValue(column, value, data) {
				var out = [],
					row;
				if (column.indexOf('.') > -1) {
					out = jpath.filter(data, "*[" + column + "=='" + value.replace(rxReplaceQuote, "$1\\\'$3") + "']");
				} else {
					for (var i = 0, m = data.length; m > i; i++) {
						row = data[i];
						if (row[column] === value) {
							APP.apply(out, [row]);
						}
					}
				}
				return out;
			}

			/**
			 * Maps unique values to rows
			 * @private
			 */

			function buildMap(data, column) {
				var tempStore = new DataStore(data),
					uniques = tempStore.unique(column),
					max = uniques.length,
					out = {},
					value;
				while (max--) {
					value = uniques[max];
					out[value] = getRowsByColumnValue(column, value, data);
				}

				return out;
			}

			return function() {
				var args = APS.apply(arguments),
					column, data, tmp = {},
					a = 0,
					max = args.length - 1;

				//Build initial Map
				column = args[a];
				tmp = buildMap(this.__data__, column);

				//Recurse through nested groups
				while (max > a) {
					column = args[++a];
					for (var key in tmp) {
						if (tmp.hasOwnProperty(key)) {
							data = tmp[key];
							tmp[key] = buildMap(data, column);
						}
					}
				}

				return tmp;
			};
		})(),
		/**
		 * Clones a DataStore returning a new copy of the same data store
		 * @returns {DataStore}
		 */
		clone: function() {
			var out = new DataStore(),
				copyOfThis = [];
			for (var i = this.__data__.length - 1, row; i >= 0; i--) {
				row = this.__data__[i];
				copyOfThis[i] = $.extend(true, {}, row);
			}
			out.concat(copyOfThis);
			return out;
		},
		/**
		 * Returns new DataStore containing top n records
		 * @param  {int} n Number of rows off the top
		 * @return {DataStore}   Subset of top n rows
		 */
		top: function(n) {
			return new DataStore(this.getRows(0, (n || 0)));
		}
	});

	module.exports = DataStore;
})(require("./jquery-core"), require("node-jpath"), null);
